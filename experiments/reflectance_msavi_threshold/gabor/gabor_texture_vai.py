# Generated by Google Ai Studio

import os
import gc
import time
from tqdm import tqdm
import warnings
from pathlib import Path
from dataclasses import dataclass, field

import numpy as np
import pandas as pd
import cupy as cp
# Use cupyx.scipy.ndimage if available and needed, otherwise scipy.ndimage
try:
    import cupyx.scipy.ndimage as ndi_cp
    print("Using cupyx.scipy.ndimage")
except ImportError:
    from scipy import ndimage as ndi_cp # Fallback or use specific scipy functions
    print("cupyx.scipy.ndimage not found, using scipy.ndimage where needed.")

import cv2
import tifffile as tiff
import rasterio
from scipy import ndimage
from skimage.filters import threshold_otsu
from skimage import exposure # Keep skimage for functions potentially not in cupy/scipy

import matplotlib.pyplot as plt
import matplotlib.colors as colors
from matplotlib.colors import LinearSegmentedColormap

# --- Placeholder/Assumed External Dependencies ---
# Make sure these modules/functions are available in your environment

# from consts import * # Assuming constants might be defined here if needed

# Assuming VegetationIndices is a class or module with static methods
class VegetationIndices:
    @staticmethod
    def calculate_msavi(red, green, blue, red_edge, nir):
        # Example implementation - replace with your actual formula
        # Ensure calculations handle potential division by zero safely
        # Using cp.errstate to suppress warnings during calculation if needed
        with cp.errstate(divide='ignore', invalid='ignore'):
            msavi = (2 * nir + 1 - cp.sqrt((2 * nir + 1)**2 - 8 * (nir - red))) / 2
            msavi[~cp.isfinite(msavi)] = 0 # Handle NaN/inf
        return msavi

    @staticmethod
    def calculate_ndvi(red, green, blue, red_edge, nir):
         with cp.errstate(divide='ignore', invalid='ignore'):
            ndvi = (nir - red) / (nir + red)
            ndvi[~cp.isfinite(ndvi)] = 0
         return ndvi
    # Add other VI methods as needed


# Assume plot_utils functions exist with these signatures
def plot_vegetation_patch_image_enhancements(og_mask, local_hist_mask,
                                             soil_vi, soil_vi_mask, soil_vi_name,
                                             vegetation_vi, rgb_patch_cpu, vegetation_vi_name, cmap,
                                             output_folder, output_filename, dpi=64):
    print(f"[Placeholder] Plotting enhancements to {output_folder}/{output_filename}")
    # Add actual plotting logic here if needed for testing, otherwise assume it works
    # Remember rgb_patch_cpu needs to be a numpy array
    fig, axes = plt.subplots(1, 2, figsize=(10, 5))
    if axes is not None and len(axes) > 0:
        axes[0].imshow(og_mask, cmap='gray')
        axes[0].set_title('Original Gabor Mask')
        axes[1].imshow(local_hist_mask, cmap='gray')
        axes[1].set_title('Local EQ Gabor Mask')
        output_path = Path(output_folder) / output_filename
        output_path.parent.mkdir(parents=True, exist_ok=True)
        plt.savefig(output_path, dpi=dpi)
        plt.close(fig) # Close figure to save memory
    else:
        print("[Placeholder] Plotting skipped due to invalid axes.")


def soil_removed_gray_and_local_eq_gabor_mask(soil_removed_gray_cpu):
    print("[Placeholder] Calculating Gabor masks...")
    # Replace with your actual Gabor implementation (using skimage.filters.gabor, etc.)
    # This function should return numpy arrays
    # Example placeholder return values:
    if soil_removed_gray_cpu is None or soil_removed_gray_cpu.size == 0:
        dummy_shape = (50, 50) # Example shape if input is invalid
        og_mask = np.zeros(dummy_shape, dtype=bool)
        local_hist_mask = np.zeros(dummy_shape, dtype=bool)
        og_mask_thresh = 0.5
        local_hist_thresh = 0.5
    else:
        try:
            og_thresh_val = threshold_otsu(soil_removed_gray_cpu[soil_removed_gray_cpu > 0]) # Threshold non-zero pixels
            og_mask = soil_removed_gray_cpu > og_thresh_val
            og_mask_thresh = float(og_thresh_val) # Ensure float
        except ValueError: # Handle cases with uniform intensity
             og_mask = np.zeros_like(soil_removed_gray_cpu, dtype=bool)
             og_mask_thresh = 0.0


        # Placeholder for local histogram equalization + Gabor
        # Replace with your actual implementation
        try:
             clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
             local_eq_img = clahe.apply(np.uint8(soil_removed_gray_cpu)) # Assuming input needs uint8
             local_thresh_val = threshold_otsu(local_eq_img[local_eq_img > 0]) # Threshold non-zero pixels
             local_hist_mask = local_eq_img > local_thresh_val
             local_hist_thresh = float(local_thresh_val) # Ensure float
        except (ValueError, cv2.error): # Handle uniform intensity or other CV errors
             local_hist_mask = np.zeros_like(soil_removed_gray_cpu, dtype=bool)
             local_hist_thresh = 0.0


    og_mask_area = np.sum(og_mask)
    local_eq_mask_area = np.sum(local_hist_mask)

    return og_mask, og_mask_thresh, og_mask_area, local_hist_mask, local_hist_thresh, local_eq_mask_area

def save_mask(mask_cpu, output_folder, output_filename):
    print(f"[Placeholder] Saving mask to {output_folder}/{output_filename}")
    output_path = Path(output_folder) / output_filename
    output_path.parent.mkdir(parents=True, exist_ok=True)
    np.save(output_path, mask_cpu) # Expects NumPy array

def save_rgb_patch_png(rgb_patch_cpu, output_folder, output_filename):
    print(f"[Placeholder] Saving RGB patch to {output_folder}/{output_filename}")
    output_path = Path(output_folder) / output_filename
    output_path.parent.mkdir(parents=True, exist_ok=True)
    # Convert to uint8 if necessary, assuming input is float [0, 1] or int
    if rgb_patch_cpu.dtype != np.uint8:
         rgb_patch_cpu = (rgb_patch_cpu * 255).clip(0, 255).astype(np.uint8)
    img = Image.fromarray(rgb_patch_cpu)
    img.save(output_path)

# --- Configuration Dataclass ---
@dataclass
class ProcessingConfig:
    patch_size: int = 512
    overlap: int = 64 # Adjusted overlap
    patch_thresh_area: int = 10000 # Min non-zero pixels to process patch
    dpi: int = 64
    soil_vi_func: callable = VegetationIndices.calculate_msavi # Function handle
    soil_vi_name: str = "MSAVI"
    vegetation_vi_func: callable = VegetationIndices.calculate_ndvi # Function handle
    vegetation_vi_name: str = "NDVI"
    # --- Optional Saving Flags ---
    save_rgb_patch: bool = False
    save_soil_vi: bool = False # If True, calculates and saves. If False, tries to load.
    save_vegetation_index_values: bool = False # Save the raw VI values?
    save_gabor_mask: bool = False
    save_gabor_fig: bool = False
    # --- Paths ---
    # Input orthomosaic_path is passed separately
    output_folder: str = "output_features"
    # Directory to load/save soil masks (required if save_soil_vi is False)
    soil_vi_mask_dir: str | None = "output_soil_masks"
    # --- Other Params ---
    # Drone type might influence RGB handling, but let's try to generalize
    # Add specific Gabor params if needed, e.g., frequencies, thetas


# --- Main Processor Class ---
class OrthomosaicProcessor:
    def __init__(self, orthomosaic_path: str, config: ProcessingConfig):
        self.orthomosaic_path = Path(orthomosaic_path)
        self.config = config
        self.bands = {} # Dictionary to store cp.array for each band
        self.profile = None # Store rasterio profile
        self.height = 0
        self.width = 0
        self.results_list = [] # Store results as list of dicts

        if not self.orthomosaic_path.exists():
            raise FileNotFoundError(f"Orthomosaic file not found: {self.orthomosaic_path}")

        # Create output dirs
        Path(self.config.output_folder).mkdir(parents=True, exist_ok=True)
        if config.soil_vi_mask_dir:
            Path(config.soil_vi_mask_dir).mkdir(parents=True, exist_ok=True)

        self._load_bands()

    def _load_bands(self):
        """Loads spectral bands from the orthomosaic GeoTIFF using rasterio."""
        print(f"Loading bands from: {self.orthomosaic_path}")
        try:
            with rasterio.open(self.orthomosaic_path) as src:
                self.profile = src.profile
                self.height, self.width = src.height, src.width
                print(f"Image dimensions: {self.height} x {self.width}")
                print(f"Band count: {src.count}")
                # Assuming standard band order: B, G, R, RE, N
                if src.count < 5:
                    raise ValueError(f"Expected at least 5 bands (B, G, R, RE, N), found {src.count}")

                # Band numbers are 1-based in rasterio
                self.bands['blue'] = cp.asarray(src.read(1), dtype=cp.float32)
                self.bands['green'] = cp.asarray(src.read(2), dtype=cp.float32)
                self.bands['red'] = cp.asarray(src.read(3), dtype=cp.float32)
                self.bands['red_edge'] = cp.asarray(src.read(4), dtype=cp.float32)
                self.bands['nir'] = cp.asarray(src.read(5), dtype=cp.float32)
                print("Bands loaded to GPU (CuPy arrays).")

                # Handle potential NoData values -> replace with 0 or NaN? Using 0 for simplicity.
                nodata = src.nodata
                if nodata is not None:
                    print(f"Replacing NoData value ({nodata}) with 0.")
                    for key in self.bands:
                        self.bands[key][self.bands[key] == nodata] = 0

        except Exception as e:
            print(f"Error loading bands: {e}")
            raise

    def _get_patch_coords(self, i: int, j: int) -> tuple[int, int, int, int]:
        """Calculates start/end coordinates for patch (i, j)."""
        stride = self.config.patch_size - self.config.overlap
        start_vert = i * stride
        end_vert = start_vert + self.config.patch_size
        start_horiz = j * stride
        end_horiz = start_horiz + self.config.patch_size
        return start_vert, end_vert, start_horiz, end_horiz

    def _extract_patch_bands(self, start_vert, end_vert, start_horiz, end_horiz) -> dict:
        """Extracts patches from all loaded bands for the given coordinates."""
        patch_bands = {}
        for name, band_data in self.bands.items():
            # Ensure slicing does not go out of bounds
            ev = min(end_vert, self.height)
            eh = min(end_horiz, self.width)
            sv = min(start_vert, ev) # Ensure start is not beyond end
            sh = min(start_horiz, eh) # Ensure start is not beyond end
            patch_bands[name] = band_data[sv:ev, sh:eh]
        return patch_bands

    def _check_patch_validity(self, patch_bands: dict) -> tuple[bool, int]:
        """Checks if a patch has enough valid pixels."""
        # Using NIR band as an example check, assuming it's representative
        # Check for non-zero pixels directly on GPU
        nir_patch = patch_bands.get('nir', None)
        if nir_patch is None or nir_patch.size == 0:
             return False, 0

        # Count non-zero pixels efficiently on GPU
        valid_area = int(cp.sum(nir_patch > 0)) # Use > 0 check

        is_valid = valid_area > self.config.patch_thresh_area
        return is_valid, valid_area

    def _calculate_vi(self, patch_bands: dict, vi_func: callable) -> cp.ndarray:
        """Calculates a vegetation index using the provided function."""
        # Pass band patches directly to the VI function
        vi = vi_func(
            patch_bands['red'], patch_bands['green'], patch_bands['blue'],
            patch_bands['red_edge'], patch_bands['nir']
        )
        # VI functions should handle NaN/inf internally
        return vi

    def _threshold_and_area(self, data_cp: cp.ndarray, method='otsu', threshold_val=None) -> tuple[cp.ndarray, float, int]:
        """Applies thresholding and calculates area."""
        if data_cp is None or data_cp.size == 0:
            return cp.array([], dtype=cp.uint8), 0.0, 0

        mask = cp.zeros_like(data_cp, dtype=cp.uint8)
        valid_pixels = data_cp[cp.isfinite(data_cp) & (data_cp != 0)] # Threshold only valid, non-zero pixels

        calculated_thresh = 0.0
        if valid_pixels.size > 0: # Ensure there are pixels to threshold
            if method == 'otsu':
                # threshold_otsu needs a NumPy array
                calculated_thresh = float(threshold_otsu(valid_pixels.get()))
                mask = cp.where(data_cp > calculated_thresh, 1, 0).astype(cp.uint8)
            elif method == 'fixed' and threshold_val is not None:
                calculated_thresh = float(threshold_val)
                mask = cp.where(data_cp > calculated_thresh, 1, 0).astype(cp.uint8)
            else:
                 print(f"Warning: Invalid threshold method '{method}' or missing threshold value.")
                 calculated_thresh = cp.nan # Indicate threshold wasn't applied properly

        # Ensure mask only covers areas where original data was valid? Optional.
        # mask[~cp.isfinite(data_cp)] = 0

        area = int(cp.sum(mask))
        return mask, calculated_thresh, area

    def _get_rgb_patch(self, patch_bands: dict) -> cp.ndarray | None:
        """Creates an RGB patch, normalizing for visualization if needed."""
        # Simple stacking, assuming bands are somewhat comparable or will be normalized later
        try:
            # Stack R, G, B
            r = patch_bands['red']
            g = patch_bands['green']
            b = patch_bands['blue']

            # Normalize each channel individually to 0-1 for basic visualization
            # More sophisticated normalization might be needed depending on data range
            def normalize_channel(channel):
                 min_val, max_val = cp.min(channel), cp.max(channel)
                 if max_val > min_val:
                     return (channel - min_val) / (max_val - min_val)
                 else:
                     return cp.zeros_like(channel) # Handle uniform channel

            r_norm = normalize_channel(r)
            g_norm = normalize_channel(g)
            b_norm = normalize_channel(b)

            rgb_patch = cp.stack([r_norm, g_norm, b_norm], axis=-1)
            return rgb_patch
        except KeyError:
            print("Warning: Could not create RGB patch, missing R, G, or B band.")
            return None
        except Exception as e:
             print(f"Error creating RGB patch: {e}")
             return None


    def _process_patch(self, i: int, j: int) -> dict | None:
        """Processes a single patch: VIs, Gabor, thresholding, areas."""
        start_time = time.time()
        patch_number_str = f"patch_{i}_{j}"
        start_vert, end_vert, start_horiz, end_horiz = self._get_patch_coords(i, j)
        patch_filename_base = f"patch_{start_vert}_{end_vert}_{start_horiz}_{end_horiz}"

        try:
            patch_bands = self._extract_patch_bands(start_vert, end_vert, start_horiz, end_horiz)

            is_valid, patch_area = self._check_patch_validity(patch_bands)
            if not is_valid:
                # print(f"Skipping patch ({i},{j}) - Area: {patch_area} <= Threshold: {self.config.patch_thresh_area}")
                return None

            # --- Prepare RGB Patch (needed for Gabor and saving) ---
            # Keep on GPU as long as possible
            rgb_patch_cp = self._get_rgb_patch(patch_bands)
            rgb_patch_gray_cp = None
            if rgb_patch_cp is not None:
                 # Convert to grayscale on GPU using weighted average (like cv2.COLOR_RGB2GRAY)
                 # Weights: 0.299*R + 0.587*G + 0.114*B
                 rgb_patch_gray_cp = (0.299 * rgb_patch_cp[..., 0] +
                                      0.587 * rgb_patch_cp[..., 1] +
                                      0.114 * rgb_patch_cp[..., 2])


            # --- Soil VI Processing ---
            soil_vi_cp = None
            soil_vi_mask_cp = None
            soil_vi_thresh = cp.nan
            soil_patch_area_pixels = patch_area # Start with total valid area
            soil_vi_filepath = None

            if self.config.soil_vi_mask_dir: # Only process soil if dir is specified
                 soil_vi_filepath = Path(self.config.soil_vi_mask_dir) / f'{patch_filename_base}_{self.config.soil_vi_name}_mask.npy'

                 if self.config.save_soil_vi:
                     soil_vi_cp = self._calculate_vi(patch_bands, self.config.soil_vi_func)
                     # Use a fixed threshold or Otsu. Example: fixed threshold for soil removal
                     # soil_vi_mask_cp, soil_vi_thresh, _ = self._threshold_and_area(soil_vi_cp, method='otsu')
                     soil_fixed_thresh = -0.2 # Example for MSAVI - Adjust as needed!
                     soil_vi_mask_cp, soil_vi_thresh, _ = self._threshold_and_area(soil_vi_cp, method='fixed', threshold_val=soil_fixed_thresh)
                     soil_vi_thresh = soil_fixed_thresh # Store the threshold used

                     # Save the calculated mask (needs CPU transfer)
                     save_mask(soil_vi_mask_cp.get(), self.config.soil_vi_mask_dir, soil_vi_filepath.name)
                 else:
                     # Try to load pre-computed soil mask
                     try:
                         soil_vi_mask_np = np.load(soil_vi_filepath)
                         soil_vi_mask_cp = cp.asarray(soil_vi_mask_np)
                         print(f"Loaded soil mask for patch ({i},{j})")
                         # We don't know the threshold if loaded, could store it separately?
                         soil_vi_thresh = cp.nan
                     except FileNotFoundError:
                         print(f"Warning: Soil mask not found at {soil_vi_filepath}. Proceeding without soil masking.")
                         soil_vi_mask_cp = cp.ones_like(patch_bands['nir'], dtype=cp.uint8) # Mask everything as non-soil if not found

            else:
                 # No soil masking requested/possible
                 soil_vi_mask_cp = cp.ones_like(patch_bands['nir'], dtype=cp.uint8) # Mask everything as non-soil


            # --- Target Vegetation VI Processing ---
            # Apply soil mask before calculating target VI
            masked_bands = {name: band * soil_vi_mask_cp for name, band in patch_bands.items()}
            vegetation_vi_cp = self._calculate_vi(masked_bands, self.config.vegetation_vi_func)
            vegetation_vi_mask_cp, vegetation_vi_thresh, vegetation_vi_area = self._threshold_and_area(vegetation_vi_cp, method='otsu')

            # --- Gabor Processing ---
            og_mask_area = cp.nan
            og_mask_thresh = cp.nan
            local_eq_mask_area = cp.nan
            local_hist_thresh = cp.nan
            og_gabor_mask_np = None # Store numpy version if needed for saving
            local_eq_gabor_mask_np = None

            if rgb_patch_gray_cp is not None:
                soil_removed_gray_cp = rgb_patch_gray_cp * soil_vi_mask_cp
                # Gabor function needs CPU data (NumPy)
                soil_removed_gray_np = soil_removed_gray_cp.get()

                # Call the external Gabor function
                (og_gabor_mask_np, og_mask_thresh, og_mask_area,
                 local_eq_gabor_mask_np, local_hist_thresh, local_eq_mask_area) = soil_removed_gray_and_local_eq_gabor_mask(soil_removed_gray_np)

            # --- Optional Saving ---
            if self.config.save_rgb_patch and rgb_patch_cp is not None:
                rgb_patch_output_folder = Path(self.config.output_folder) / 'RGB_Patch'
                rgb_patch_output_filename = f'{patch_filename_base}_rgb.png'
                save_rgb_patch_png(rgb_patch_cp.get(), str(rgb_patch_output_folder), rgb_patch_output_filename)

            if self.config.save_vegetation_index_values:
                vi_values_output_folder = Path(self.config.output_folder) / self.config.vegetation_vi_name
                vi_values_output_filename = f'{patch_filename_base}_{self.config.vegetation_vi_name}.npy'
                save_mask(vegetation_vi_cp.get(), str(vi_values_output_folder), vi_values_output_filename)

            if self.config.save_gabor_mask and og_gabor_mask_np is not None and local_eq_gabor_mask_np is not None:
                og_gabor_mask_output_folder = Path(self.config.output_folder) / 'OriginalGrayscale_Mask'
                og_gabor_mask_filename = f'{patch_filename_base}_original_gabor_mask.npy'
                save_mask(og_gabor_mask_np, str(og_gabor_mask_output_folder), og_gabor_mask_filename)

                local_eq_gabor_mask_output_folder = Path(self.config.output_folder) / 'LocalHistEq_Mask'
                local_eq_gabor_mask_filename = f'{patch_filename_base}_local_eq_gabor_mask.npy'
                save_mask(local_eq_gabor_mask_np, str(local_eq_gabor_mask_output_folder), local_eq_gabor_mask_filename)

            if self.config.save_gabor_fig and og_gabor_mask_np is not None and local_eq_gabor_mask_np is not None and rgb_patch_cp is not None:
                 # Plotting requires CPU data
                 fig_output_folder = Path(self.config.output_folder) / 'Gabor_Comparison_Plots'
                 fig_output_filename = f"{patch_filename_base}_gabor_comp.png"
                 jet_cmap = LinearSegmentedColormap.from_list('jet', ['black', 'blue', 'green', 'yellow', 'red', 'white'], N=256)

                 plot_vegetation_patch_image_enhancements(
                     og_gabor_mask_np, local_eq_gabor_mask_np,
                     soil_vi_cp.get() if soil_vi_cp is not None else None, # Pass CPU arrays
                     soil_vi_mask_cp.get() if soil_vi_mask_cp is not None else None,
                     self.config.soil_vi_name,
                     vegetation_vi_cp.get() if vegetation_vi_cp is not None else None,
                     rgb_patch_cp.get(), # Pass CPU array
                     self.config.vegetation_vi_name, jet_cmap,
                     str(fig_output_folder), fig_output_filename, dpi=self.config.dpi
                 )


            # --- Collect Results ---
            patch_results = {
                "patch": patch_number_str,
                "start_vert": start_vert,
                "end_vert": end_vert,
                "start_horiz": start_horiz,
                "end_horiz": end_horiz,
                "Patch_Area_Pixels": patch_area,
                "VegetationIndex": self.config.vegetation_vi_name,
                "VI_Thresh": float(vegetation_vi_thresh) if cp.isfinite(vegetation_vi_thresh) else None,
                "VI_Area_Pixels": vegetation_vi_area,
                "SoilIndex": self.config.soil_vi_name if self.config.soil_vi_mask_dir else "N/A",
                "Soil_VI_Thresh": float(soil_vi_thresh) if cp.isfinite(soil_vi_thresh) else None,
                "Pure_GaborArea_Pixels": int(og_mask_area) if not np.isnan(og_mask_area) else None,
                "Pure_GaborThresh": float(og_mask_thresh) if not np.isnan(og_mask_thresh) else None,
                "LocalHistEq_GaborArea_Pixels": int(local_eq_mask_area) if not np.isnan(local_eq_mask_area) else None,
                "LocalHistEq_GaborThresh": float(local_hist_thresh) if not np.isnan(local_hist_thresh) else None,
                "Processing_Time_s": time.time() - start_time
            }
            return patch_results

        except Exception as e:
            print(f"ERROR processing patch ({i},{j}): {e}")
            traceback.print_exc()
            # Return minimal info for tracking errors
            return {
                "patch": patch_number_str,
                 "start_vert": start_vert, "end_vert": end_vert,
                 "start_horiz": start_horiz, "end_horiz": end_horiz,
                 "error": str(e)
            }
        finally:
            # Explicitly clear large intermediate GPU arrays for this patch
            # Might not be strictly necessary with CuPy's pool, but can help
            del patch_bands, rgb_patch_cp, rgb_patch_gray_cp, soil_vi_cp, soil_vi_mask_cp
            del masked_bands, vegetation_vi_cp, vegetation_vi_mask_cp
            # np arrays cleared automatically when function exits or via Python GC
            gc.collect() # Optional: Keep if memory pressure is high


    def run_processing(self) -> pd.DataFrame:
        """Iterates through patches, processes them, and returns results."""
        print("Starting patch processing...")
        self.results_list = [] # Reset results

        stride = self.config.patch_size - self.config.overlap
        if stride <= 0:
             raise ValueError("Patch size must be greater than overlap.")

        num_patches_vert = max(1, (self.height - self.config.overlap + stride - 1) // stride)
        num_patches_horiz = max(1, (self.width - self.config.overlap + stride - 1) // stride)

        print(f"Grid size: {num_patches_vert} (vertical) x {num_patches_horiz} (horizontal)")
        total_patches = num_patches_vert * num_patches_horiz

        with tqdm(total=total_patches, desc="Processing Patches") as pbar:
            for i in range(num_patches_vert):
                for j in range(num_patches_horiz):
                    result = self._process_patch(i, j)
                    if result is not None:
                        self.results_list.append(result)
                    pbar.update(1)

        print(f"\nPatch processing finished. Collected results for {len(self.results_list)} patches.")

        # --- Finalize ---
        # Release GPU memory explicitly if bands are large
        del self.bands
        cp.get_default_memory_pool().free_all_blocks()
        gc.collect()
        print("GPU memory cleared.")

        if not self.results_list:
             print("Warning: No valid patches processed.")
             return pd.DataFrame() # Return empty DataFrame

        # Create DataFrame from the list of dictionaries
        final_df = pd.DataFrame(self.results_list)
        return final_df

# --- Main Execution Example ---
if __name__ == "__main__":
    warnings.filterwarnings("ignore", category=rasterio.errors.NotGeoreferencedWarning)
    warnings.filterwarnings("ignore", category=RuntimeWarning) # Ignore CuPy/NumPy runtime warnings (e.g., div by zero)


    # --- Configuration ---
    # Adjust paths and parameters as needed
    ORTHO_PATH = "path/to/your/orthomosaic_5band.tif" # IMPORTANT: Update this path
    OUTPUT_FOLDER = "processing_output"
    SOIL_MASK_FOLDER = "soil_masks" # Folder to store/load soil masks

    config = ProcessingConfig(
        patch_size=512,
        overlap=64,
        patch_thresh_area=5000, # Lower threshold for testing?
        soil_vi_func=VegetationIndices.calculate_msavi,
        soil_vi_name="MSAVI",
        vegetation_vi_func=VegetationIndices.calculate_ndvi,
        vegetation_vi_name="NDVI",
        output_folder=OUTPUT_FOLDER,
        soil_vi_mask_dir=SOIL_MASK_FOLDER,
        # --- Set save flags to True if you want intermediate outputs ---
        save_rgb_patch=False,
        save_soil_vi=True, # Set to True to calculate and save soil masks first time
                           # Set to False to load existing soil masks (requires soil_vi_mask_dir)
        save_vegetation_index_values=False,
        save_gabor_mask=False,
        save_gabor_fig=False,
        dpi=72
    )

    # --- Run Processing ---
    if not Path(ORTHO_PATH).exists():
         print(f"Error: Orthomosaic file not found at {ORTHO_PATH}")
         print("Please update the ORTHO_PATH variable.")
    else:
        try:
            processor = OrthomosaicProcessor(orthomosaic_path=ORTHO_PATH, config=config)
            results_df = processor.run_processing()

            # --- Save Final DataFrame ---
            if not results_df.empty:
                output_csv_path = Path(config.output_folder) / f"{Path(ORTHO_PATH).stem}_features.csv"
                results_df.to_csv(output_csv_path, index=False)
                print(f"\nResults saved to: {output_csv_path}")
                print("\nFinal DataFrame Head:")
                print(results_df.head())
            else:
                 print("\nNo results generated.")

        except FileNotFoundError as e:
             print(f"Error: {e}")
        except ValueError as e:
             print(f"Configuration Error: {e}")
        except Exception as e:
            print(f"An unexpected error occurred during processing: {e}")
            traceback.print_exc()