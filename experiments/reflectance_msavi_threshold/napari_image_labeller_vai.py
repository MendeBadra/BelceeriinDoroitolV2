# Generated by Google Ai studio
import numpy as np
import pandas as pd
import napari
import imageio.v3 as iio
from magicgui import magicgui, widgets
from pathlib import Path
import sys
from datetime import datetime
import warnings

# --- Configuration ---
N_RANDOM = 50 # Default number of points
N_PIXELS_ZOOM = 15 # Determines zoom level (approx neighborhood size)
DEFAULT_MODE = 'rgb' # Initial view mode
# Base directory containing land type subfolders (Worst_10, Bad_10, etc.)
# BASE_INPUT_DIR = Path("/media/razydave/HDD/MendeFolder/BelceeriinDoroitol/experiments/reflectance_msavi_threshold/output_ref4")
BASE_INPUT_DIR = Path("/media/razydave/CenAppMath/Baasanjargal_Khustai_analysis/Label_images")
# Directory to save label files
DEFAULT_OUTPUT_DIR = Path("./napari_labels") # Save in current dir by default

# --- Helper Functions ---

def generate_random_pts(rows, cols, n):
    """Generates n unique random points within image bounds."""
    rng = np.random.default_rng()
    points = set()
    while len(points) < n:
        i_ind = rng.integers(0, rows) # row index
        j_ind = rng.integers(0, cols) # col index
        points.add((i_ind, j_ind))
        if len(points) % 100 == 0: # Progress for large N
             print(f"Generated {len(points)} unique points...")
    print(f"Successfully generated {len(points)} unique points.")
    return np.array(list(points)) # Return as numpy array (rows, cols) -> (y, x)

def get_land_type_path(base_dir: Path) -> tuple[Path | None, str | None]:
    """Prompts user for land type and returns the corresponding path and name."""
    land_types = ["worst", "bad", "medium", "good", "best"]
    folders = {
        0: "worst_10", 1: "bad_10", 2: "medium_10", 3: "good_10", 4: "best"
    }

    while True:
        try:
            choice_str = input(
                "Select land type number [0: worst, 1: bad, 2: medium, 3: good, 4: best]: "
            )
            if not choice_str:
                 print("No input provided. Exiting.")
                 return None, None
            choice = int(choice_str)
            if 0 <= choice <= 4:
                land_folder_name = folders[choice]
                land_type_name = land_types[choice]
                path = base_dir / land_folder_name
                if path.exists() and path.is_dir():
                    print(f"Selected land type: {land_type_name} ({path})")
                    return path, land_type_name
                else:
                    print(f"Error: Directory not found: {path}")
                    return None, None # Exit if dir not found
            else:
                print("Invalid choice. Please enter a number between 0 and 4.")
        except ValueError:
            print("Invalid input. Please enter a number.")
        except Exception as e:
             print(f"An error occurred: {e}")
             return None, None

def load_required_images(land_path: Path) -> dict | None:
    """Loads Red, Green, Blue, and MSAVI images from the specified path."""
    required_files = {
        # Assuming consistent naming patterns - adjust if needed
        "red": "*red_reference.tif",
        "green": "*green*.tif",
        "blue": "*blue*.tif",
        "msavi": "*msavi_scaled*.tif",
        # "ndvi": "*ndvi*.tif" # Optional: uncomment if needed
    }
    images = {}
    print(f"Searching for images in: {land_path}")

    for name, pattern in required_files.items():
        found_files = list(land_path.glob(pattern))
        if not found_files:
            print(f"Error: Could not find required '{name}' image using pattern '{pattern}' in {land_path}")
            return None
        if len(found_files) > 1:
            warnings.warn(f"Warning: Found multiple files for '{name}' using pattern '{pattern}'. Using the first one: {found_files[0].name}")
        try:
             print(f"Loading {name} from {found_files[0].name}...")
             images[name] = iio.imread(found_files[0])
             print(f"  -> Loaded {name} with shape: {images[name].shape}, dtype: {images[name].dtype}")
        except Exception as e:
             print(f"Error loading image file {found_files[0]}: {e}")
             return None

    # Validate shapes (optional but recommended)
    ref_shape = images["red"].shape
    for name, img in images.items():
         if img.shape != ref_shape:
              warnings.warn(f"Warning: Shape mismatch! {name} shape {img.shape} != reference shape {ref_shape}")
              # Decide how to handle: error out, resize, or just warn
              # print(f"Error: Image shapes do not match. {name} shape is {img.shape}, expected {ref_shape}")
              # return None # Example: Error out if shapes don't match

    return images

# --- State Management Class ---
class LabelingState:
    def __init__(self, viewer, images, points_to_label, land_name, output_dir):
        self.viewer = viewer
        self.images = images # Dict of numpy arrays
        self.points_to_label = points_to_label # Nx2 numpy array [i, j] or [y, x]
        self.land_name = land_name
        self.output_dir = Path(output_dir)

        self.labeled_data = [] # List to store results [{'i': y, 'j': x, 'label': 'v'/'g'}]
        self.current_index = -1 # Start before the first point
        self.n_total_points = len(points_to_label)
        self.current_mode = DEFAULT_MODE # 'rgb' or 'msavi'

        self.rgb_layer = None
        self.msavi_layer = None
        self.points_layer = None
        self.status_widget = widgets.Label(value="Initializing...")

    def setup_layers(self):
        """Adds image and points layers to the viewer."""
        # Stack RGB
        try:
            rgb_image = np.stack([self.images['red'], self.images['green'], self.images['blue']], axis=-1)
            self.rgb_layer = self.viewer.add_image(rgb_image, name='RGB', rgb=True)
            print(f"Added RGB layer: {self.rgb_layer.name}")
        except KeyError as e:
             print(f"Error: Missing required image for RGB stacking: {e}")
             return False
        except ValueError as e:
             print(f"Error stacking RGB images (check shapes and dtype): {e}")
             return False

        # Add MSAVI (initially invisible)
        if 'msavi' in self.images:
             self.msavi_layer = self.viewer.add_image(self.images['msavi'], name='MSAVI', colormap='viridis', visible=False)
             print(f"Added MSAVI layer: {self.msavi_layer.name}")
        else:
            print("Warning: MSAVI image not found or loaded.")

        # --- Modified Points Layer Setup ---
        # Napari points layer expects data as (y, x) or (z, y, x)
        # Our points are already (row, col) which is (y, x)
        point_properties = {'status': ['unlabeled'] * self.n_total_points}
        # Define the colors for the *outline* based on status
        status_edge_color_map = {
             'unlabeled': 'red',       # Unlabeled points outlined in red
             'current': 'yellow',    # Current point outlined in yellow
             'labeled_v': 'lime',      # Vegetation outlined in green
             'labeled_g': 'saddlebrown' # Ground outlined in brown
        }

        self.points_layer = self.viewer.add_points(
            self.points_to_label,
            name='PointsToLabel',
            properties=point_properties,
            symbol='square',          # Use a square marker
            size=1,                   # Set size to 1 data unit (effectively 1 pixel)
            border_width=0.1, # Make edge thin relative to size 1, adjust as needed (e.g., 0.05, 0.1)
                              # Thicker lines (like 1.5) might look too blocky for size=1
            border_color='status',      # Color the *edge* based on the 'status' property
            face_color='transparent', # Make the inside of the square transparent
            border_color_cycle=status_edge_color_map, # Use the map defined above
            # face_color_cycle=..., # Not needed as face is transparent
        )

        # Ensure edge color mode is set correctly (it usually defaults to direct or cycle
        # when edge_color is set to a property name and edge_color_cycle is provided)
        # Explicitly setting it can sometimes help clarity or resolve issues:
        # self.points_layer.edge_color_mode = 'cycle' # Often inferred correctly

        print(f"Added Points layer: {self.points_layer.name} with {self.n_total_points} points (as pixel outlines).")
        return True
    # --- End Modified Section ---

    def update_status_text(self):
        """Updates the status label widget."""
        labeled_count = len(self.labeled_data)
        remaining = self.n_total_points - (self.current_index + 1)
        if self.current_index >= self.n_total_points:
             status = f"Finished! {labeled_count} labeled. Press 'S' to save or 'Q' to quit."
        elif self.current_index < 0:
             status = f"Press 'N' for Next Point ({self.n_total_points} total)"
        else:
            y, x = self.points_to_label[self.current_index]
            if self.current_mode == 'rgb':
                image = np.stack([self.images['red'], self.images['green'], self.images['blue']], axis=-1)
            else:
                image = self.images['msavi']
            status = (f"Point {self.current_index + 1}/{self.n_total_points} at ({y}, {x}). "
                      f"Mode: {self.current_mode.upper()} of value {image[y, x]}. "
                      f"Labeled: {labeled_count}. Remaining: {remaining}. "
                      f"Keys: [V]eg, [G]round, [T]skip, [R]toggle view, [B]ack, [S]ave, [Q]uit")
        self.status_widget.value = status
        print(status) # Also print to console

    def go_to_point(self, index):
        """Moves focus to the point at the given index."""
        if not (0 <= index < self.n_total_points):
            if index >= self.n_total_points:
                 print("All points processed.")
                 self.current_index = self.n_total_points # Set index past the end
                 self.update_status_text()
            # else: # index < 0, ignore
            #      print("Already at the first point.")
            return

        # Reset previous point's visual status if it was 'current'
        if self.current_index >= 0:
            # Check if the previous point was actually labeled
            prev_labeled = False
            for item in self.labeled_data:
                if item['index'] == self.current_index:
                    self.points_layer.properties['status'][self.current_index] = f"labeled_{item['label']}"
                    prev_labeled = True
                    break
            if not prev_labeled:
                 # If we moved back or skipped, reset to unlabeled
                 self.points_layer.properties['status'][self.current_index] = 'unlabeled'


        # Update current index
        self.current_index = index
        y, x = self.points_to_label[self.current_index]

        # Highlight current point
        # Temporarily store original status before marking as 'current'
        # This might be overcomplex, let's just use the 'current' status directly.
        self.points_layer.properties['status'][self.current_index] = 'current'
        self.points_layer.refresh_colors() # Crucial to update visuals

        # Zoom and center view
        # Calculate approximate zoom level based on desired pixel neighborhood
        # This is heuristic - adjust zoom factor as needed
        pixels_per_world_unit = self.viewer.camera.zoom * max(self.viewer.window.qt_viewer.width(), self.viewer.window.qt_viewer.height()) / N_PIXELS_ZOOM
        zoom_factor = 150 / N_PIXELS_ZOOM # Heuristic factor, adjust as needed
        self.viewer.camera.center = (y, x)
        self.viewer.camera.zoom = zoom_factor

        self.update_status_text()

    def label_current_point(self, label):
        """Assigns the given label ('v' or 'g') to the current point."""
        if not (0 <= self.current_index < self.n_total_points):
            print("No current point selected or finished.")
            return

        y, x = self.points_to_label[self.current_index]
        # Remove any existing label for this index (if going back and re-labeling)
        self.labeled_data = [item for item in self.labeled_data if item['index'] != self.current_index]
        # Add new label
        self.labeled_data.append({'index': self.current_index, 'i': y, 'j': x, 'label': label})
        print(f"Labeled point {self.current_index + 1} ({y}, {x}) as {'Vegetation' if label == 'v' else 'Ground'}")

        # Update point status visually
        self.points_layer.properties['status'][self.current_index] = f"labeled_{label}"
        self.points_layer.refresh_colors()

        # Move to the next point
        self.go_to_point(self.current_index + 1)

    def skip_point(self):
        """Skips the current point (moves to next without labeling)."""
        if not (0 <= self.current_index < self.n_total_points):
            print("No current point selected or finished.")
            return

        y, x = self.points_to_label[self.current_index]
        print(f"Skipping point {self.current_index + 1} ({y}, {x})")
        # Ensure visual status is reset from 'current'
        self.points_layer.properties['status'][self.current_index] = 'unlabeled' # Mark as unlabeled visually
        self.points_layer.refresh_colors()
        # Remove any potential label from labeled_data if user went back and then skipped
        self.labeled_data = [item for item in self.labeled_data if item['index'] != self.current_index]

        self.go_to_point(self.current_index + 1)

    def go_back(self):
        """Moves to the previous point."""
        if self.current_index <= 0:
             print("Cannot go back further.")
             # Reset index if we were at 0, so 'N' works
             if self.current_index == 0:
                  self.points_layer.properties['status'][self.current_index] = 'unlabeled'
                  self.points_layer.refresh_colors()
                  self.current_index = -1
                  self.update_status_text()
             return

        # Remove the label for the point we *were* about to process or just processed
        # This happens implicitly when label_current_point runs again for the previous index
        # We just need to visually reset the point we are leaving
        if self.current_index < self.n_total_points: # Avoid index error if already finished
             self.points_layer.properties['status'][self.current_index] = 'unlabeled'
             self.points_layer.refresh_colors()

        # Remove the label data entry corresponding to the point we are going *back* to
        prev_index = self.current_index - 1
        self.labeled_data = [item for item in self.labeled_data if item['index'] != prev_index]
        print(f"Going back to point {prev_index + 1}. Re-label if needed.")
        self.go_to_point(prev_index)

    def toggle_view_mode(self):
        """Switches between RGB and MSAVI views."""
        if not self.msavi_layer:
            print("MSAVI layer not available.")
            return

        if self.current_mode == 'rgb':
            self.current_mode = 'msavi'
            self.rgb_layer.visible = False
            self.msavi_layer.visible = True
            print("Switched view to MSAVI")
        else:
            self.current_mode = 'rgb'
            self.rgb_layer.visible = True
            self.msavi_layer.visible = False
            print("Switched view to RGB")
        self.update_status_text()

    def save_results(self):
        """Saves the labeled data to a CSV file."""
        if not self.labeled_data:
            print("No labels to save.")
            return

        self.output_dir.mkdir(parents=True, exist_ok=True)
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = self.output_dir / f"{self.land_name}_labels_{timestamp}.csv"

        # Prepare DataFrame
        df = pd.DataFrame(self.labeled_data)
        df = df[['i', 'j', 'label']] # Select and order columns

        try:
            df.to_csv(filename, index=False)
            print(f"Labels saved successfully to: {filename}")
            self.status_widget.value = f"Saved to {filename}"
        except Exception as e:
            print(f"Error saving labels to {filename}: {e}")
            self.status_widget.value = f"Error saving: {e}"

# --- Main Execution ---
def main():
    # 1. Get Land Type and Load Images
    land_path, land_name = get_land_type_path(BASE_INPUT_DIR)
    if not land_path:
        sys.exit("Exiting: No valid land type selected or path found.")

    images = load_required_images(land_path)
    if not images:
        sys.exit("Exiting: Failed to load required images.")

    # Determine image dimensions from one of the loaded images
    ref_img_name = next(iter(images)) # Get the first key
    rows, cols = images[ref_img_name].shape[:2]
    print(f"Image dimensions: {rows} rows, {cols} cols")

    # 2. Generate Random Points
    n_points_actual = N_RANDOM
    try:
         n_points_str = input(f"Enter number of random points to sample (default {N_RANDOM}): ")
         if n_points_str: # Only parse if user provided input
              n_points_actual = int(n_points_str)
              if n_points_actual <= 0:
                   print("Number of points must be positive. Using default.")
                   n_points_actual = N_RANDOM
    except ValueError:
         print("Invalid number entered. Using default.")
         n_points_actual = N_RANDOM

    random_points = generate_random_pts(rows, cols, n=n_points_actual)

    # 3. Initialize Napari Viewer and State
    viewer = napari.Viewer(title=f"Labeling: {land_name}")
    state = LabelingState(viewer, images, random_points, land_name, DEFAULT_OUTPUT_DIR)

    if not state.setup_layers():
         sys.exit("Exiting: Failed to set up Napari layers.")

    # 4. Add GUI Elements (Status Label and Save Button)
    status_widget_container = widgets.Container(widgets=[state.status_widget])
    viewer.window.add_dock_widget(status_widget_container, area='bottom', name='Status')

    @magicgui(call_button="Save Labels (S)")
    def save_button():
        state.save_results()

    viewer.window.add_dock_widget(save_button, area='right', name='Actions')


    # 5. Define Key Bindings
    @viewer.bind_key('n', overwrite=True) # Next point (useful to start)
    def next_point(viewer):
        if state.current_index == -1: # Only works if not started
             state.go_to_point(0)
        else:
             print("Already started. Use 'V', 'G', or 'T' to advance.")

    @viewer.bind_key('v', overwrite=True) # Label as Vegetation
    def label_veg(viewer):
        state.label_current_point('v')

    @viewer.bind_key('g', overwrite=True) # Label as Ground
    def label_ground(viewer):
        state.label_current_point('g')

    @viewer.bind_key('t', overwrite=True) # Skip point
    def skip(viewer):
         state.skip_point()

    @viewer.bind_key('r', overwrite=True) # Toggle RGB/MSAVI view
    def toggle_mode(viewer):
        state.toggle_view_mode()

    @viewer.bind_key('b', overwrite=True) # Go Back
    def go_back_key(viewer):
        state.go_back()

    @viewer.bind_key('s', overwrite=True) # Save
    def save_key(viewer):
        state.save_results()

    @viewer.bind_key('q', overwrite=True) # Quit
    def quit_napari(viewer):
        print("Quitting...")
        viewer.close()

    # Initial state update
    state.update_status_text()

    # 6. Run Napari
    napari.run()

    # 7. Post-run (optional cleanup or final save prompt)
    print("\nNapari closed.")
    if state.labeled_data:
        print(f"Collected {len(state.labeled_data)} labels for {state.land_name}.")
        # Optionally prompt to save again if not saved via 'S'
    else:
        print("No labels were collected.")

if __name__ == "__main__":
    main()



# How to Use:

# Save: Save the code above as a Python file (e.g., napari_labeler.py).

# Install Libraries: Make sure you have napari, numpy, pandas, imageio, magicgui, and qtpy (usually installed with napari) installed (pip install napari[all] numpy pandas imageio magicgui).

# Prepare Data: Ensure your image data is organized as expected:

# A base directory (like /media/razydave/HDD/MendeFolder/BelceeriinDoroitol/RandomForests/output).

# Inside, subdirectories named Worst_10, Bad_10, etc.

# Inside each subdirectory, TIFF files containing "red", "green", "blue", and "msavi" in their names (e.g., ortho_red_reference.tif, ortho_msavi.tif). Adjust the load_required_images function if your naming patterns differ.

# Run: Open a terminal in the directory where you saved the script and run: python napari_labeler.py

# Select Land Type: The script will prompt you to enter a number (0-4) corresponding to the land type you want to label.

# Select Number of Points: It will then ask how many random points you want to sample (press Enter for the default 50).

# Napari Interface:

# Napari will open showing the RGB image and the random points (initially red).

# A status bar at the bottom will guide you.

# A "Save Labels" button appears on the right.

# Labeling Workflow:

# Press N to start and go to the first point. The view will zoom in, and the current point will turn yellow.

# Press V to label the center of the zoomed view (the yellow point) as Vegetation. The point will turn green-ish, and you'll automatically advance to the next point.

# Press G to label as Ground. The point turns brown-ish, and you advance.

# Press T to Skip the current point without labeling. You advance to the next point.

# Press R to Toggle the main view between RGB and MSAVI.

# Press B to go Back to the previous point. If it was labeled, the label is removed, allowing you to re-label.

# Press S (or click the button) to Save the currently collected labels to a CSV file in the napari_labels subdirectory (or the specified DEFAULT_OUTPUT_DIR). The filename includes the land type and a timestamp.

# Press Q to Quit Napari.

# Output: The saved CSV file will have columns i, j, label, where i is the row index and j is the column index.